#!/usr/bin/python

from __future__ import print_function

import argparse
import logging
import re
import sys

import pip.index
import pip.req
import pkg_resources


BAD_REQUIREMENTS = 2
INCOMPATIBLE_REQUIREMENTS = 3
logger = logging.getLogger()


class RequirementException(Exception):
    pass


def create_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-r", "--requirement",
        dest="requirements",
        nargs="*",
        default=[],
        metavar="<file>",
        help="Install all the packages listed in the given requirements file")
    parser.add_argument(
        "requirement_specs",
        nargs="*",
        default=[],
        metavar="<requirement specifier>",
        help="Install specified package")
    parser.add_argument(
        # A regex to be used to skip requirements
        "--skip-requirements-regex",
        default="",
        help=argparse.SUPPRESS)
    parser.add_argument(
        # The default version control system for editables, e.g. 'svn'
        '--default-vcs',
        dest='default_vcs',
        default='',
        help=argparse.SUPPRESS)
    parser.add_argument(
        "--debug", "-d",
        action="store_true",
        default=False,
        help="Print debug information")
    parser.add_argument(
        "--ignore-packages",
        nargs="*",
        default=[],
        metavar="<requirement specifier>",
        help="Ignore listed packages")
    return parser


def setup_logging(options):
    level = logging.DEBUG if options.debug else logging.WARNING
    handler = logging.StreamHandler(sys.stderr)
    logger.addHandler(handler)
    logger.setLevel(level)


def install_requirement_ensure_req_field(req):
    if not hasattr(req, 'req') or not req.req:
        # pip 0.8 or so
        link = pip.index.Link(req.url)
        name = link.egg_fragment
        if not name:
            raise Exception("Cannot find package name from `%s'" % req.url)
        req.req = pkg_resources.Requirement.parse(name)
    return req


def install_requirement_str(req):
    return req.url or str(req.req)


def install_requirement_parse(line, comes_from):
    line = line.strip()
    if line.startswith('-e') or line.startswith('--editable'):
        if line.startswith('-e'):
            line = line[2:].strip()
        else:
            line = line[len('--editable'):].strip().lstrip('=')
        req = pip.req.InstallRequirement.from_editable(
            line, comes_from=comes_from)
    else:
        req = pip.req.InstallRequirement.from_line(line, comes_from)
    return install_requirement_ensure_req_field(req)


def score(versioned):
    if not versioned:
        return sys.maxint
    if len(versioned) == 1:
        return 0
    not_allowed = set()
    exacts = set()
    for (bound, version) in versioned:
        if bound == "!=":
            not_allowed.add(version)
        if bound == "==":
            exacts.add(version)
    score = 0
    if exacts:
        for (bound, version) in versioned:
            if bound == "==":
                continue
            if version not in exacts:
                score += 1
    if not_allowed:
        for (bound, version) in versioned:
            if bound in ["!=", ">", "<"]:
                continue
            if version in not_allowed:
                score += 1
    for (bound, version) in versioned:
        if bound in [">=", ">"]:
            for (bound2, version2) in versioned:
                if (bound2, version2) == (bound, version):
                    continue
                if bound2 == "<" and version2 < version:
                    score += 1
                if bound2 == "<=" and bound == ">" and version2 <= version:
                    score += 1
                if bound2 == "==" and bound == "<" and version2 >= version:
                    score += 1
        if bound in ["<=", "<"]:
            for (bound2, version2) in versioned:
                if (bound2, version2) == (bound, version):
                    continue
                if bound2 == ">" and version2 > version:
                    score += 1
                if bound2 == ">=" and bound == "<" and version2 >= version:
                    score += 1
                if bound2 == "==" and bound == ">" and version2 <= version:
                    score += 1
    return score


def _memoized_score(versioned, scored):
    versioned = tuple(versioned)
    for saved, saved_score in scored:
        if saved == versioned:
            return (True, saved_score)
    s = score(versioned)
    scored.append((versioned, s))
    return (False, s)


def _recursive_score(versioned, scored):
    memoized, best_score = _memoized_score(versioned, scored)
    best_match = list(versioned)
    if memoized:
        return (best_score, best_match)
    for i, _spec in enumerate(versioned):
        tmp_versioned = list(versioned)
        tmp_versioned.pop(i)
        tmp_score, tmp_match = _recursive_score(tmp_versioned, scored)
        if tmp_score < best_score:
            best_match = list(tmp_match)
            best_score = tmp_score
    return (best_score, best_match)


def find_best_match(versioned):
    scored = []
    _recursive_score(versioned, scored)

    def score_sort(item1, item2):
        c = cmp(item1[1], item2[1])
        if c == 0:
            return cmp(item1[0], item2[0])
        return c

    # Find the lowest score with the highest number of elements.
    scored = list(sorted(scored, cmp=score_sort))
    min_score = sys.maxint
    for saved, saved_score in scored:
        if saved_score < min_score:
            min_score = saved_score
    max_elems = -1
    best_match = []
    for saved, saved_score in scored:
        if min_score == saved_score:
            if len(saved) > max_elems:
                best_match = list(saved)
                max_elems = len(saved)
    baddies = set()
    for saved_specs, _saved_score in scored:
        for spec in saved_specs:
            if spec not in best_match:
                baddies.add(spec)
    return (best_match, baddies)


def match(name, specs):
    versions = {}

    def reform(specs):
        pieces = []
        for (bound, version) in specs:
            pieces.append("%s%s" % (bound, str(versions[version])))
        spec = "%s%s" % (name, ",".join(pieces))
        return pip.req.InstallRequirement.from_line(spec, 'compiled')

    versioned = set()
    for (bound, version) in specs:
        v = pkg_resources.parse_version(version)
        versioned.add((bound, v))
        versions[v] = version
    versioned = list(versioned)
    initial_score = score(versioned)
    if initial_score == 0:
        return (reform(versioned), [])
    else:
        best_match, incompat_versions = find_best_match(versioned)
        incompats = [reform([s]) for s in incompat_versions]
        return (reform(best_match), incompats)


def parse_requirements(options):
    """Parse package requirements from command line and files.

    :return: tuple (all, ignored) of InstallRequirement
    """
    all_requirements = {}
    skip_match = None
    if options.skip_requirements_regex:
        skip_match = re.compile(options.skip_requirements_regex)
    for req_spec in options.requirement_specs:
        try:
            req = install_requirement_parse(req_spec, "command line")
            if skip_match and skip_match.search(req.req.key):
                continue
            all_requirements.setdefault(req.req.key, []).append(req)
        except Exception as ex:
            raise RequirementException("Cannot parse `%s': %s" % (req_spec, ex))
    for filename in options.requirements:
        try:
            for req in pip.req.parse_requirements(filename):
                req = install_requirement_ensure_req_field(req)
                if skip_match and skip_match.search(req.req.key):
                    continue
                all_requirements.setdefault(req.req.key, []).append(req)
        except Exception as ex:
            raise RequirementException("Cannot parse `%s': %s" % (filename, ex))
    ignored_requirements = []
    for req_spec in options.ignore_packages:
        try:
            req = install_requirement_parse(req_spec, "command line")
            ignored_requirements.append(req)
        except Exception as ex:
            raise RequirementException("Cannot parse `%s': %s" % (req_spec, ex))
    return all_requirements, ignored_requirements


def join_requirements(options):
    all_requirements, ignored_requirements = parse_requirements(options)
    skip_keys = set(pkg.req.key for pkg in ignored_requirements)

    incompatibles = {}
    joined_requirements = []
    for req_key, req_list in all_requirements.iteritems():
        if req_key in skip_keys:
            continue
        specs = []
        for req in req_list:
            specs.extend(req.req.specs)
        best_match, incompats = match(req_key, specs)
        joined_requirements.append(best_match)
        incompatibles[req_key] = incompats
    return (joined_requirements, incompatibles)


def print_requirements(joined_requirements):
    formatted_requirements = []
    for req in joined_requirements:
        if req.url:
            req = "%s#egg=%s" % (req.url, req.req)
        else:
            req = str(req.req)
        formatted_requirements.append(req)
    for req in sorted(formatted_requirements):
        print(req)


def print_incompatibles(incompatibles):
    for req_key in sorted(incompatibles.keys()):
        print("%s: incompatible requirements" % req_key,
              file=sys.stderr)
        print("Conflicting:", file=sys.stderr)
        for conflicting in incompatibles[req_key]:
            print("\t%s: %s" % (conflicting.comes_from,
                                install_requirement_str(conflicting)),
                  file=sys.stderr)


def main():
    parser = create_parser()
    options = parser.parse_args()
    setup_logging(options)
    try:
        joined_requirements, incompatibles = join_requirements(options)
    except RequirementException as ex:
        logger.error("Requirement failure: %s", ex)
        sys.exit(BAD_REQUIREMENTS)
    print_incompatibles(incompatibles)
    print_requirements(joined_requirements)
    if incompatibles:
        sys.exit(INCOMPATIBLE_REQUIREMENTS)


if __name__ == "__main__":
    main()
