#!/usr/bin/python

from __future__ import print_function

import argparse
import itertools
import logging
import re
import sys

import pip.index
import pip.req
import pkg_resources


BAD_REQUIREMENTS = 2
INCOMPATIBLE_REQUIREMENTS = 3
logger = logging.getLogger()


class RequirementException(Exception):
    pass


def create_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-r", "--requirement",
        dest="requirements",
        nargs="*",
        default=[],
        metavar="<file>",
        help="Install all the packages listed in the given requirements file")
    parser.add_argument(
        "requirement_specs",
        nargs="*",
        default=[],
        metavar="<requirement specifier>",
        help="Install specified package")
    parser.add_argument(
        # A regex to be used to skip requirements
        "--skip-requirements-regex",
        default="",
        help=argparse.SUPPRESS)
    parser.add_argument(
        # The default version control system for editables, e.g. 'svn'
        '--default-vcs',
        dest='default_vcs',
        default='',
        help=argparse.SUPPRESS)
    parser.add_argument(
        "--debug", "-d",
        action="store_true",
        default=False,
        help="Print debug information")
    parser.add_argument(
        "--ignore-packages",
        nargs="*",
        default=[],
        metavar="<requirement specifier>",
        help="Ignore listed packages")
    return parser


def setup_logging(options):
    level = logging.DEBUG if options.debug else logging.WARNING
    handler = logging.StreamHandler(sys.stderr)
    logger.addHandler(handler)
    logger.setLevel(level)


def install_requirement_ensure_req_field(req):
    if not hasattr(req, 'req') or not req.req:
        # pip 0.8 or so
        link = pip.index.Link(req.url)
        name = link.egg_fragment
        if not name:
            raise Exception("Cannot find package name from `%s'" % req.url)
        req.req = pkg_resources.Requirement.parse(name)
    return req


def install_requirement_str(req):
    return req.url or str(req.req)


def install_requirement_parse(line, comes_from):
    line = line.strip()
    if line.startswith('-e') or line.startswith('--editable'):
        if line.startswith('-e'):
            line = line[2:].strip()
        else:
            line = line[len('--editable'):].strip().lstrip('=')
        req = pip.req.InstallRequirement.from_editable(
            line, comes_from=comes_from)
    else:
        req = pip.req.InstallRequirement.from_line(line, comes_from)
    return install_requirement_ensure_req_field(req)


def iter_combinations(elements):
    """Iterates over all combinations of the given elements list."""
    for r in range(0, len(elements) + 1):
        for c in itertools.combinations(elements, r):
            yield c


def score(versioned):
    """Scores a list of (bound, version) tuples, a higher score means more
    conflicts while a lower score means less conflicts.
    """
    if len(versioned) == 1:
        return 0
    not_allowed = set()
    exacts = set()
    for (bound, version) in versioned:
        if bound == "!=":
            not_allowed.add(version)
        if bound == "==":
            exacts.add(version)
    score = 0
    for version in exacts:
        for (bound, version2) in versioned:
            if version != version2:
                score += 1
    for version in not_allowed:
        for (bound, version2) in versioned:
            if bound in ["!=", ">", "<"]:
                continue
            if version2 == version:
                score += 1
    for (bound, version) in versioned:
        if bound == ">":
            for (bound2, version2) in versioned:
                if (bound2, version2) == (bound, version):
                    continue
                if bound2 in ["<", "<="] and version2 <= version:
                    score += 1
        if bound == ">=":
            for (bound2, version2) in versioned:
                if (bound2, version2) == (bound, version):
                    continue
                if bound2 in ["<", "<="] and version2 < version:
                    score += 1
        if bound == "<":
            for (bound2, version2) in versioned:
                if (bound2, version2) == (bound, version):
                    continue
                if bound2 in [">", ">="] and version2 >= version:
                    score += 1
        if bound == "<=":
            for (bound2, version2) in versioned:
                if (bound2, version2) == (bound, version):
                    continue
                if bound2 in [">", ">="] and version2 > version:
                    score += 1
    return score


def find_best_match(versioned):
    """Iterates over all combinations of the given version and comparator in
    the provided lists and finds the one with the best score (closest to zero
    with the maximum number of elements).
    """
    scored = []
    for combo in iter_combinations(versioned):
        if not len(combo):
            continue
        scored.append((combo, score(combo)))

    # Find the lowest score with the highest number of elements.
    min_score = sys.maxint
    for combo, combo_score in scored:
        if combo_score < min_score:
            min_score = combo_score
    max_elems = -1
    best_match = []
    for combo, combo_score in scored:
        if min_score == combo_score:
            if len(combo) > max_elems:
                best_match = list(combo)
                max_elems = len(combo)
    incompatibles = set()
    for combo, _score in scored:
        for spec in combo:
            if spec not in best_match:
                incompatibles.add(spec)
    return (best_match, incompatibles)


def best_match(req_key, req_list):
    """Attempts to find the versions which will work the best for the given
    requirement specification list.
    """
    all_specs = []
    req_specs = []
    for req in req_list:
        if req.req.specs:
            all_specs.extend(req.req.specs)
            req_specs.append((req, tuple(req.req.specs)))
    if not all_specs:
        return (req_list[0], [])

    def spec_sort(spec1, spec2):
        (bound1, version1) = spec1
        (bound2, version2) = spec2
        c = cmp(version1, version2)
        if c == 0:
            c = cmp(bound1, bound2)
        return c

    def reform(specs, versions):
        right_versions = []
        for (bound, version) in specs:
            right_versions.append((bound, versions[version]))
        for req, req_spec in req_specs:
            if tuple(right_versions) == req_spec:
                return req
        spec_pieces = []
        for (bound, version) in right_versions:
            spec_pieces.append("%s%s" % (bound, version))
        spec = "%s%s" % (req_key, ",".join(spec_pieces))
        return pip.req.InstallRequirement.from_line(spec, 'compiled')

    versions = {}
    versioned = set()
    for (bound, version) in all_specs:
        v = pkg_resources.parse_version(version)
        versioned.add((bound, v))
        versions[v] = version
    versioned = list(sorted(versioned, cmp=spec_sort))
    initial_score = score(versioned)
    if initial_score == 0:
        return (reform(versioned, versions), [])
    else:
        match, incompatibles = find_best_match(versioned)
        incompatibles = [reform([s], versions) for s in incompatibles]
        return (reform(match, versions), incompatibles)


def parse_requirements(options):
    """Parse package requirements from command line and files.

    :return: tuple (all, ignored) of InstallRequirement
    """
    all_requirements = {}
    skip_match = None
    if options.skip_requirements_regex:
        skip_match = re.compile(options.skip_requirements_regex)
    for req_spec in options.requirement_specs:
        try:
            req = install_requirement_parse(req_spec, "command line")
            if skip_match and skip_match.search(req.req.key):
                continue
            all_requirements.setdefault(req.req.key, []).append(req)
        except Exception as ex:
            raise RequirementException("Cannot parse `%s': %s" % (req_spec, ex))
    for filename in options.requirements:
        try:
            for req in pip.req.parse_requirements(filename):
                req = install_requirement_ensure_req_field(req)
                if skip_match and skip_match.search(req.req.key):
                    continue
                all_requirements.setdefault(req.req.key, []).append(req)
        except Exception as ex:
            raise RequirementException("Cannot parse `%s': %s" % (filename, ex))
    ignored_requirements = []
    for req_spec in options.ignore_packages:
        try:
            req = install_requirement_parse(req_spec, "command line")
            ignored_requirements.append(req)
        except Exception as ex:
            raise RequirementException("Cannot parse `%s': %s" % (req_spec, ex))
    return all_requirements, ignored_requirements


def join_requirements(options):
    all_requirements, ignored_requirements = parse_requirements(options)
    skip_keys = set(pkg.req.key for pkg in ignored_requirements)
    incompatibles = {}
    joined_requirements = []
    for req_key, req_list in all_requirements.iteritems():
        if req_key in skip_keys:
            continue
        match, req_incompatibles = best_match(req_key, req_list)
        joined_requirements.append(match)
        incompatibles[req_key] = req_incompatibles
    return (joined_requirements, incompatibles)


def print_requirements(joined_requirements):
    formatted_requirements = []
    for req in joined_requirements:
        if req.url:
            req = "%s#egg=%s" % (req.url, req.req)
        else:
            req = str(req.req)
        formatted_requirements.append(req)
    for req in sorted(formatted_requirements):
        print(req)


def print_incompatibles(incompatibles):
    for req_key in sorted(incompatibles.keys()):
        req_incompatibles = incompatibles[req_key]
        if not req_incompatibles:
            continue
        print("%s: incompatible requirements" % req_key,
              file=sys.stderr)
        print("Conflicting:", file=sys.stderr)
        for conflicting in req_incompatibles:
            print("\t%s: %s" % (conflicting.comes_from,
                                install_requirement_str(conflicting)),
                  file=sys.stderr)


def main():
    parser = create_parser()
    options = parser.parse_args()
    setup_logging(options)
    try:
        joined_requirements, incompatibles = join_requirements(options)
    except RequirementException as ex:
        logger.error("Requirement failure: %s", ex)
        sys.exit(BAD_REQUIREMENTS)
    print_incompatibles(incompatibles)
    print_requirements(joined_requirements)
    if incompatibles:
        sys.exit(INCOMPATIBLE_REQUIREMENTS)


if __name__ == "__main__":
    main()
